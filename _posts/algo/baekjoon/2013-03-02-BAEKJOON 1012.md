---
title: "BAE/<JOON 1012"
date: 2013-03-01 08:26:28 -0400
categories: algo
---
---

> 유기농 배추 : [GO 1012]

### CODE
```java
public class Main {
	public static int[] dx = { 0, 0, 1, -1 };
	public static int[] dy = { 1, -1, 0, 0 };
	public static int[][] numbers, temp;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int t = sc.nextInt();

		for (int index = 0; index < t; index++) {
			int m = sc.nextInt();
			int n = sc.nextInt();
			int k = sc.nextInt();
			numbers = new int[m][n];
			temp = new int[m][n];
			for (int i = 0; i < k; i++) {
				int x = sc.nextInt();
				int y = sc.nextInt();
				numbers[x][y] = 1;
			}	 
			System.out.println(solve(numbers, temp, 0, m, n));
		}
	}

	public static int solve(int[][] numbers, int[][] temp, int count, int m, int n) {
		for (int i = 0; i < m; i++)
			for (int j = 0; j < n; j++)
				if (numbers[i][j] == 1 && temp[i][j] == 0)
					dfs(numbers, temp, i, j, ++count, m, n);
		return count;
	}

	public static void dfs(int[][] numbers, int[][] temp, int x, int y, int count, int m, int n) {
		temp[x][y] = count;
		for (int i = 0; i < 4; i++) {
			int nx = x + dx[i];
			int ny = y + dy[i];
			if (nx >= 0 && nx < m && ny >= 0 && ny < n)
				if (numbers[nx][ny] == 1 && temp[nx][ny] == 0)
					dfs(numbers, temp, nx, ny, count, m, n);		
		}
	}
}
```

### COMMENT
* 인접 행렬 + DFS
* dx, dy : 상하좌우 이동을 위한 배열
* temp : 단지번호 결과물 배열

[GO 1012]: https://www.acmicpc.net/problem/1012
